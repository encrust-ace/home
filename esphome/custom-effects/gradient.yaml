addressable_lambda:
  name: "Gradient"
  update_interval: 16ms
  lambda: |-
    // Check size directly from the vector
    if (id(palette_colors).size() < 2) return;

    uint32_t speed = (uint32_t) id(effect_speed).state;
    uint32_t global_offset = ((uint64_t) millis() * speed) >> 6;

    int num_leds = it.size();
    
    // Use .size() here. Casting to (int) helps avoid signed/unsigned warnings
    int palette_count = (int)id(palette_colors).size();
    int palette_steps = palette_count * 256;
    uint32_t step = palette_steps / num_leds;

    for (int i = 0; i < num_leds; i++) {
      uint16_t pos = (global_offset + (i * step)) % palette_steps;

      int idx = pos >> 8;
      uint8_t blend = pos & 0xFF;
      uint8_t inv = 255 - blend;

      Color a = id(palette_colors)[idx];
      // Use .size() for the wrap-around logic
      Color b = id(palette_colors)[(idx + 1) % palette_count];

      it[i] = Color(
        (a.r * inv + b.r * blend) >> 8,
        (a.g * inv + b.g * blend) >> 8,
        (a.b * inv + b.b * blend) >> 8,
        (a.w * inv + b.w * blend) >> 8
      );
    }